{"version":3,"file":"carousel.component.d.ts","sources":["carousel.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\n/****\n * Problems:\n * 1) if we set an active slide via model changes, .active class remains on a\n * current slide.\n * 2) if we have only one slide, we shouldn't show prev/next nav buttons\n * 3) if first or last slide is active and noWrap is true, there should be\n * \"disabled\" class on the nav buttons.\n * 4) default interval should be equal 5000\n */\nimport { EventEmitter, NgZone, OnDestroy, AfterViewInit } from '@angular/core';\nimport { LinkedList } from 'ngx-bootstrap/utils';\nimport { SlideComponent } from './slide.component';\nimport { CarouselConfig } from './carousel.config';\nimport { SlideWithIndex } from './models';\nexport declare enum Direction {\n    UNKNOWN = 0,\n    NEXT = 1,\n    PREV = 2\n}\n/**\n * Base element to create carousel\n */\nexport declare class CarouselComponent implements AfterViewInit, OnDestroy {\n    private ngZone;\n    noWrap: boolean;\n    noPause: boolean;\n    showIndicators: boolean;\n    pauseOnFocus: boolean;\n    indicatorsByChunk: boolean;\n    itemsPerSlide: number;\n    singleSlideOffset: boolean;\n    /** Turn on/off animation. Animation doesn't work for multilist carousel */\n    isAnimated: boolean;\n    /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n    activeSlideChange: EventEmitter<number>;\n    /** Will be emitted when active slides has been changed in multilist mode */\n    slideRangeChange: EventEmitter<number[]>;\n    /** Index of currently displayed slide(started for 0) */\n    activeSlide: number;\n    startFromIndex: number;\n    /**\n     * Delay of item cycling in milliseconds. If false, carousel won't cycle\n     * automatically.\n     */\n    interval: number;\n    readonly slides: SlideComponent[];\n    protected currentInterval: any;\n    protected _currentActiveSlide: number;\n    protected _interval: number;\n    protected _slides: LinkedList<SlideComponent>;\n    protected _chunkedSlides: SlideWithIndex[][];\n    protected _slidesWithIndexes: SlideWithIndex[];\n    protected _currentVisibleSlidesIndex: number;\n    protected isPlaying: boolean;\n    protected destroyed: boolean;\n    readonly isBs4: boolean;\n    constructor(config: CarouselConfig, ngZone: NgZone);\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Adds new slide. If this slide is first in collection - set it as active\n     * and starts auto changing\n     * @param slide\n     */\n    addSlide(slide: SlideComponent): void;\n    /**\n     * Removes specified slide. If this slide is active - will roll to another\n     * slide\n     * @param slide\n     */\n    removeSlide(slide: SlideComponent): void;\n    nextSlideFromInterval(force?: boolean): void;\n    /**\n     * Rolling to next slide\n     * @param force: {boolean} if true - will ignore noWrap flag\n     */\n    nextSlide(force?: boolean): void;\n    /**\n     * Rolling to previous slide\n     * @param force: {boolean} if true - will ignore noWrap flag\n     */\n    previousSlide(force?: boolean): void;\n    getFirstVisibleIndex(): number;\n    getLastVisibleIndex(): number;\n    getActive: (slide: SlideComponent) => boolean;\n    move(direction: Direction, force?: boolean): void;\n    /**\n     * Swith slides by enter, space and arrows keys\n     * @internal\n     */\n    keydownPress(event: KeyboardEvent): void;\n    /**\n     * Play on mouse leave\n     * @internal\n     */\n    onMouseLeave(): void;\n    /**\n     * Play on mouse up\n     * @internal\n     */\n    onMouseUp(): void;\n    /**\n     * When slides on focus autoplay is stopped(optional)\n     * @internal\n     */\n    pauseFocusIn(): void;\n    /**\n     * When slides out of focus autoplay is started\n     * @internal\n     */\n    pauseFocusOut(): void;\n    /**\n     * Rolling to specified slide\n     * @param index: {number} index of slide, which must be shown\n     */\n    selectSlide(index: number): void;\n    /**\n     * Starts a auto changing of slides\n     */\n    play(): void;\n    /**\n     * Stops a auto changing of slides\n     */\n    pause(): void;\n    /**\n     * Finds and returns index of currently displayed slide\n     */\n    getCurrentSlideIndex(): number;\n    /**\n     * Defines, whether the specified index is last in collection\n     * @param index\n     */\n    isLast(index: number): boolean;\n    /**\n     * Defines, whether the specified index is first in collection\n     * @param index\n     */\n    isFirst(index: number): boolean;\n    indicatorsSlides(): SlideComponent[];\n    private selectInitialSlides;\n    /**\n     * Defines next slide index, depending of direction\n     * @param direction: Direction(UNKNOWN|PREV|NEXT)\n     * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n     *   return undefined if next slide require wrapping\n     */\n    private findNextSlideIndex;\n    private mapSlidesAndIndexes;\n    private selectSlideRange;\n    private selectRangeByNestedIndex;\n    private isIndexOnTheEdges;\n    private isIndexInRange;\n    private hideSlides;\n    private isVisibleSlideListLast;\n    private isVisibleSlideListFirst;\n    private moveSliderByOneItem;\n    private makeSlidesConsistent;\n    private moveMultilist;\n    private getVisibleIndexes;\n    /**\n     * Sets a slide, which specified through index, as active\n     * @param index\n     */\n    private _select;\n    /**\n     * Starts loop of auto changing of slides\n     */\n    private restartTimer;\n    readonly multilist: boolean;\n    /**\n     * Stops loop of auto changing of slides\n     */\n    private resetTimer;\n}\n"]}