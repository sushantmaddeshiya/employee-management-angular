(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/common'),exports, require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-bootstrap/tabs', ['@angular/core','@angular/common','exports', '@angular/core', '@angular/common'], factory) :
    (global = global || self, factory(global.ng.core,global.ng.common,(global['ngx-bootstrap'] = global['ngx-bootstrap'] || {}, global['ngx-bootstrap'].tabs = {}), global.ng.core, global.ng.common));
}(this, (function (ɵngcc0,ɵngcc1,exports, core, common) { 
function TabsetComponent_li_1_span_4_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 7);
    ɵngcc0.ɵɵlistener("click", function TabsetComponent_li_1_span_4_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var tabz_r1 = ɵngcc0.ɵɵnextContext().$implicit; var ctx_r4 = ɵngcc0.ɵɵnextContext(); $event.preventDefault(); return ctx_r4.removeTab(tabz_r1); });
    ɵngcc0.ɵɵtext(1, " \u274C");
    ɵngcc0.ɵɵelementEnd();
} }
var _c0 = function (a1) { return ["nav-item", a1]; };
function TabsetComponent_li_1_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 3);
    ɵngcc0.ɵɵlistener("keydown", function TabsetComponent_li_1_Template_li_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var i_r2 = ctx.index; var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.keyNavActions($event, i_r2); });
    ɵngcc0.ɵɵelementStart(1, "a", 4);
    ɵngcc0.ɵɵlistener("click", function TabsetComponent_li_1_Template_a_click_1_listener() { var tabz_r1 = ctx.$implicit; return tabz_r1.active = true; });
    ɵngcc0.ɵɵelementStart(2, "span", 5);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, TabsetComponent_li_1_span_4_Template, 2, 0, "span", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tabz_r1 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("active", tabz_r1.active)("disabled", tabz_r1.disabled);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(15, _c0, tabz_r1.customClass || ""));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("active", tabz_r1.active)("disabled", tabz_r1.disabled);
    ɵngcc0.ɵɵattribute("aria-controls", tabz_r1.id ? tabz_r1.id : "")("aria-selected", !!tabz_r1.active)("id", tabz_r1.id ? tabz_r1.id + "-link" : "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTransclude", tabz_r1.headingRef);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(tabz_r1.heading);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tabz_r1.removable);
} }
var _c1 = ["*"];
'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgTranscludeDirective = /** @class */ (function () {
        function NgTranscludeDirective(viewRef) {
            this.viewRef = viewRef;
        }
        Object.defineProperty(NgTranscludeDirective.prototype, "ngTransclude", {
            /* tslint:disable-next-line:no-any */
            get: /* tslint:disable-next-line:no-any */
            /**
             * @return {?}
             */
            function () {
                return this._ngTransclude;
            },
            set: /**
             * @param {?} templateRef
             * @return {?}
             */
            function (templateRef) {
                this._ngTransclude = templateRef;
                if (templateRef) {
                    this.viewRef.createEmbeddedView(templateRef);
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @nocollapse */
        NgTranscludeDirective.ctorParameters = function () { return [
            { type: core.ViewContainerRef }
        ]; };
        NgTranscludeDirective.propDecorators = {
            ngTransclude: [{ type: core.Input }]
        };
NgTranscludeDirective.ɵfac = function NgTranscludeDirective_Factory(t) { return new (t || NgTranscludeDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
NgTranscludeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgTranscludeDirective, selectors: [["", "ngTransclude", ""]], inputs: { ngTransclude: "ngTransclude" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgTranscludeDirective, [{
        type: core.Directive,
        args: [{
                selector: '[ngTransclude]'
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, { ngTransclude: [{
            type: core.Input
        }] }); })();
        return NgTranscludeDirective;
    }());
    if (false) {
        /** @type {?} */
        NgTranscludeDirective.prototype.viewRef;
        /**
         * @type {?}
         * @protected
         */
        NgTranscludeDirective.prototype._viewRef;
        /**
         * @type {?}
         * @protected
         */
        NgTranscludeDirective.prototype._ngTransclude;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TabsetConfig = /** @class */ (function () {
        function TabsetConfig() {
            /**
             * provides default navigation context class: 'tabs' or 'pills'
             */
            this.type = 'tabs';
            /**
             * aria label for tab list
             */
            this.ariaLabel = 'Tabs';
        }
TabsetConfig.ɵfac = function TabsetConfig_Factory(t) { return new (t || TabsetConfig)(); };
TabsetConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TabsetConfig, factory: function (t) { return TabsetConfig.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabsetConfig, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return TabsetConfig;
    }());
    if (false) {
        /**
         * provides default navigation context class: 'tabs' or 'pills'
         * @type {?}
         */
        TabsetConfig.prototype.type;
        /**
         * aria label for tab list
         * @type {?}
         */
        TabsetConfig.prototype.ariaLabel;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // todo: add active event to tab
    // todo: fix? mixing static and dynamic tabs position tabs in order of creation
    var TabsetComponent = /** @class */ (function () {
        function TabsetComponent(config, renderer, elementRef) {
            this.renderer = renderer;
            this.elementRef = elementRef;
            this.clazz = true;
            this.tabs = [];
            this.classMap = {};
            Object.assign(this, config);
        }
        Object.defineProperty(TabsetComponent.prototype, "vertical", {
            /** if true tabs will be placed vertically */
            get: /**
             * if true tabs will be placed vertically
             * @return {?}
             */
            function () {
                return this._vertical;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._vertical = value;
                this.setClassMap();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabsetComponent.prototype, "justified", {
            /** if true tabs fill the container and have a consistent width */
            get: /**
             * if true tabs fill the container and have a consistent width
             * @return {?}
             */
            function () {
                return this._justified;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._justified = value;
                this.setClassMap();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabsetComponent.prototype, "type", {
            /** navigation context class: 'tabs' or 'pills' */
            get: /**
             * navigation context class: 'tabs' or 'pills'
             * @return {?}
             */
            function () {
                return this._type;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._type = value;
                this.setClassMap();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TabsetComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.isDestroyed = true;
        };
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsetComponent.prototype.addTab = /**
         * @param {?} tab
         * @return {?}
         */
        function (tab) {
            this.tabs.push(tab);
            tab.active = this.tabs.length === 1 && typeof tab.active === 'undefined';
        };
        /**
         * @param {?} tab
         * @param {?=} options
         * @return {?}
         */
        TabsetComponent.prototype.removeTab = /**
         * @param {?} tab
         * @param {?=} options
         * @return {?}
         */
        function (tab, options) {
            if (options === void 0) { options = { reselect: true, emit: true }; }
            /** @type {?} */
            var index = this.tabs.indexOf(tab);
            if (index === -1 || this.isDestroyed) {
                return;
            }
            // Select a new tab if the tab to be removed is selected and not destroyed
            if (options.reselect && tab.active && this.hasAvailableTabs(index)) {
                /** @type {?} */
                var newActiveIndex = this.getClosestTabIndex(index);
                this.tabs[newActiveIndex].active = true;
            }
            if (options.emit) {
                tab.removed.emit(tab);
            }
            this.tabs.splice(index, 1);
            if (tab.elementRef.nativeElement.parentNode) {
                this.renderer.removeChild(tab.elementRef.nativeElement.parentNode, tab.elementRef.nativeElement);
            }
        };
        /* tslint:disable-next-line: cyclomatic-complexity */
        /* tslint:disable-next-line: cyclomatic-complexity */
        /**
         * @param {?} event
         * @param {?} index
         * @return {?}
         */
        TabsetComponent.prototype.keyNavActions = /* tslint:disable-next-line: cyclomatic-complexity */
        /**
         * @param {?} event
         * @param {?} index
         * @return {?}
         */
        function (event, index) {
            /** @type {?} */
            var list = Array.from(this.elementRef.nativeElement.querySelectorAll('.nav-link'));
            // const activeElList = list.filter((el: HTMLElement) => !el.classList.contains('disabled'));
            // tslint:disable-next-line:deprecation
            if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {
                event.preventDefault();
                /** @type {?} */
                var currentTab = list[(index) % list.length];
                currentTab.click();
                return;
            }
            // tslint:disable-next-line:deprecation
            if (event.keyCode === 39 || event.key === 'RightArrow') {
                /** @type {?} */
                var nextTab = void 0;
                /** @type {?} */
                var shift = 1;
                do {
                    nextTab = list[(index + shift) % list.length];
                    shift++;
                } while (nextTab.classList.contains('disabled'));
                nextTab.focus();
                return;
            }
            // tslint:disable-next-line:deprecation
            if (event.keyCode === 37 || event.key === 'LeftArrow') {
                /** @type {?} */
                var previousTab = void 0;
                /** @type {?} */
                var shift = 1;
                /** @type {?} */
                var i = index;
                do {
                    if ((i - shift) < 0) {
                        i = list.length - 1;
                        previousTab = list[i];
                        shift = 0;
                    }
                    else {
                        previousTab = list[i - shift];
                    }
                    shift++;
                } while (previousTab.classList.contains('disabled'));
                previousTab.focus();
                return;
            }
            // tslint:disable-next-line:deprecation
            if (event.keyCode === 36 || event.key === 'Home') {
                event.preventDefault();
                /** @type {?} */
                var firstTab = void 0;
                /** @type {?} */
                var shift = 0;
                do {
                    firstTab = list[shift % list.length];
                    shift++;
                } while (firstTab.classList.contains('disabled'));
                firstTab.focus();
                return;
            }
            // tslint:disable-next-line:deprecation
            if (event.keyCode === 35 || event.key === 'End') {
                event.preventDefault();
                /** @type {?} */
                var lastTab = void 0;
                /** @type {?} */
                var shift = 1;
                /** @type {?} */
                var i = index;
                do {
                    if ((i - shift) < 0) {
                        i = list.length - 1;
                        lastTab = list[i];
                        shift = 0;
                    }
                    else {
                        lastTab = list[i - shift];
                    }
                    shift++;
                } while (lastTab.classList.contains('disabled'));
                lastTab.focus();
                return;
            }
            // tslint:disable-next-line:deprecation
            if (event.keyCode === 46 || event.key === 'Delete') {
                if (this.tabs[index].removable) {
                    this.removeTab(this.tabs[index]);
                    if (list[index + 1]) {
                        list[(index + 1) % list.length].focus();
                        return;
                    }
                    if (list[list.length - 1]) {
                        list[0].focus();
                    }
                }
            }
        };
        /**
         * @protected
         * @param {?} index
         * @return {?}
         */
        TabsetComponent.prototype.getClosestTabIndex = /**
         * @protected
         * @param {?} index
         * @return {?}
         */
        function (index) {
            /** @type {?} */
            var tabsLength = this.tabs.length;
            if (!tabsLength) {
                return -1;
            }
            for (var step = 1; step <= tabsLength; step += 1) {
                /** @type {?} */
                var prevIndex = index - step;
                /** @type {?} */
                var nextIndex = index + step;
                if (this.tabs[prevIndex] && !this.tabs[prevIndex].disabled) {
                    return prevIndex;
                }
                if (this.tabs[nextIndex] && !this.tabs[nextIndex].disabled) {
                    return nextIndex;
                }
            }
            return -1;
        };
        /**
         * @protected
         * @param {?} index
         * @return {?}
         */
        TabsetComponent.prototype.hasAvailableTabs = /**
         * @protected
         * @param {?} index
         * @return {?}
         */
        function (index) {
            /** @type {?} */
            var tabsLength = this.tabs.length;
            if (!tabsLength) {
                return false;
            }
            for (var i = 0; i < tabsLength; i += 1) {
                if (!this.tabs[i].disabled && i !== index) {
                    return true;
                }
            }
            return false;
        };
        /**
         * @protected
         * @return {?}
         */
        TabsetComponent.prototype.setClassMap = /**
         * @protected
         * @return {?}
         */
        function () {
            var _a;
            this.classMap = (_a = {
                    'nav-stacked': this.vertical,
                    'flex-column': this.vertical,
                    'nav-justified': this.justified
                },
                _a["nav-" + this.type] = true,
                _a);
        };
        /** @nocollapse */
        TabsetComponent.ctorParameters = function () { return [
            { type: TabsetConfig },
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        TabsetComponent.propDecorators = {
            vertical: [{ type: core.Input }],
            justified: [{ type: core.Input }],
            type: [{ type: core.Input }],
            clazz: [{ type: core.HostBinding, args: ['class.tab-container',] }]
        };
TabsetComponent.ɵfac = function TabsetComponent_Factory(t) { return new (t || TabsetComponent)(ɵngcc0.ɵɵdirectiveInject(TabsetConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
TabsetComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TabsetComponent, selectors: [["tabset"]], hostVars: 2, hostBindings: function TabsetComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("tab-container", ctx.clazz);
    } }, inputs: { vertical: "vertical", justified: "justified", type: "type" }, ngContentSelectors: _c1, decls: 4, vars: 3, consts: [["role", "tablist", 1, "nav", 3, "ngClass", "click"], [3, "ngClass", "active", "disabled", "keydown", 4, "ngFor", "ngForOf"], [1, "tab-content"], [3, "ngClass", "keydown"], ["href", "javascript:void(0);", "role", "tab", 1, "nav-link", 3, "click"], [3, "ngTransclude"], ["class", "bs-remove-tab", 3, "click", 4, "ngIf"], [1, "bs-remove-tab", 3, "click"]], template: function TabsetComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵlistener("click", function TabsetComponent_Template_ul_click_0_listener($event) { return $event.preventDefault(); });
        ɵngcc0.ɵɵtemplate(1, TabsetComponent_li_1_Template, 5, 17, "li", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.classMap);
        ɵngcc0.ɵɵattribute("aria-label", ctx.ariaLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs);
    } }, directives: [ɵngcc1.NgClass, ɵngcc1.NgForOf, NgTranscludeDirective, ɵngcc1.NgIf], styles: ["[_nghost-%COMP%]   .nav-tabs[_ngcontent-%COMP%]   .nav-item.disabled[_ngcontent-%COMP%]   a.disabled[_ngcontent-%COMP%]{cursor:default}"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabsetComponent, [{
        type: core.Component,
        args: [{
                selector: 'tabset',
                template: "<ul class=\"nav\" [ngClass]=\"classMap\"\n    (click)=\"$event.preventDefault()\"\n    [attr.aria-label]=\"ariaLabel\"\n    role=\"tablist\">\n  <li *ngFor=\"let tabz of tabs; let i = index\" [ngClass]=\"['nav-item', tabz.customClass || '']\"\n      [class.active]=\"tabz.active\" [class.disabled]=\"tabz.disabled\" (keydown)=\"keyNavActions($event, i)\">\n    <a href=\"javascript:void(0);\" class=\"nav-link\" role=\"tab\"\n       [attr.aria-controls]=\"tabz.id ? tabz.id : ''\"\n       [attr.aria-selected]=\"!!tabz.active\"\n       [attr.id]=\"tabz.id ? tabz.id + '-link' : ''\"\n       [class.active]=\"tabz.active\" [class.disabled]=\"tabz.disabled\"\n       (click)=\"tabz.active = true\">\n      <span [ngTransclude]=\"tabz.headingRef\">{{ tabz.heading }}</span>\n      <span *ngIf=\"tabz.removable\" (click)=\"$event.preventDefault(); removeTab(tabz);\" class=\"bs-remove-tab\"> &#10060;</span>\n    </a>\n  </li>\n</ul>\n<div class=\"tab-content\">\n  <ng-content></ng-content>\n</div>\n",
                styles: [":host .nav-tabs .nav-item.disabled a.disabled{cursor:default}"]
            }]
    }], function () { return [{ type: TabsetConfig }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { clazz: [{
            type: core.HostBinding,
            args: ['class.tab-container']
        }], vertical: [{
            type: core.Input
        }], justified: [{
            type: core.Input
        }], type: [{
            type: core.Input
        }] }); })();
        return TabsetComponent;
    }());
    if (false) {
        /** @type {?} */
        TabsetComponent.prototype.clazz;
        /** @type {?} */
        TabsetComponent.prototype.tabs;
        /** @type {?} */
        TabsetComponent.prototype.classMap;
        /**
         * aria label for tab list
         * @type {?}
         */
        TabsetComponent.prototype.ariaLabel;
        /**
         * @type {?}
         * @protected
         */
        TabsetComponent.prototype.isDestroyed;
        /**
         * @type {?}
         * @protected
         */
        TabsetComponent.prototype._vertical;
        /**
         * @type {?}
         * @protected
         */
        TabsetComponent.prototype._justified;
        /**
         * @type {?}
         * @protected
         */
        TabsetComponent.prototype._type;
        /**
         * @type {?}
         * @private
         */
        TabsetComponent.prototype.renderer;
        /**
         * @type {?}
         * @private
         */
        TabsetComponent.prototype.elementRef;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TabDirective = /** @class */ (function () {
        function TabDirective(tabset, elementRef, renderer) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            /**
             * fired when tab became active, $event:Tab equals to selected instance of Tab component
             */
            this.selectTab = new core.EventEmitter();
            /**
             * fired when tab became inactive, $event:Tab equals to deselected instance of Tab component
             */
            this.deselect = new core.EventEmitter();
            /**
             * fired before tab will be removed, $event:Tab equals to instance of removed tab
             */
            this.removed = new core.EventEmitter();
            this.addClass = true;
            this.role = 'tabpanel';
            this.tabset = tabset;
            this.tabset.addTab(this);
        }
        Object.defineProperty(TabDirective.prototype, "customClass", {
            /** if set, will be added to the tab's class attribute. Multiple classes are supported. */
            get: /**
             * if set, will be added to the tab's class attribute. Multiple classes are supported.
             * @return {?}
             */
            function () {
                return this._customClass;
            },
            set: /**
             * @param {?} customClass
             * @return {?}
             */
            function (customClass) {
                var _this = this;
                if (this.customClass) {
                    this.customClass.split(' ').forEach((/**
                     * @param {?} cssClass
                     * @return {?}
                     */
                    function (cssClass) {
                        _this.renderer.removeClass(_this.elementRef.nativeElement, cssClass);
                    }));
                }
                this._customClass = customClass ? customClass.trim() : null;
                if (this.customClass) {
                    this.customClass.split(' ').forEach((/**
                     * @param {?} cssClass
                     * @return {?}
                     */
                    function (cssClass) {
                        _this.renderer.addClass(_this.elementRef.nativeElement, cssClass);
                    }));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabDirective.prototype, "active", {
            /** tab active state toggle */
            get: /**
             * tab active state toggle
             * @return {?}
             */
            function () {
                return this._active;
            },
            set: /**
             * @param {?} active
             * @return {?}
             */
            function (active) {
                var _this = this;
                if (this._active === active) {
                    return;
                }
                if ((this.disabled && active) || !active) {
                    if (this._active && !active) {
                        this.deselect.emit(this);
                        this._active = active;
                    }
                    return;
                }
                this._active = active;
                this.selectTab.emit(this);
                this.tabset.tabs.forEach((/**
                 * @param {?} tab
                 * @return {?}
                 */
                function (tab) {
                    if (tab !== _this) {
                        tab.active = false;
                    }
                }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabDirective.prototype, "ariaLabelledby", {
            get: /**
             * @return {?}
             */
            function () {
                return this.id ? this.id + "-link" : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TabDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.removable = this.removable;
        };
        /**
         * @return {?}
         */
        TabDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.tabset.removeTab(this, { reselect: false, emit: false });
        };
        /** @nocollapse */
        TabDirective.ctorParameters = function () { return [
            { type: TabsetComponent },
            { type: core.ElementRef },
            { type: core.Renderer2 }
        ]; };
        TabDirective.propDecorators = {
            heading: [{ type: core.Input }],
            id: [{ type: core.HostBinding, args: ['attr.id',] }, { type: core.Input }],
            disabled: [{ type: core.Input }],
            removable: [{ type: core.Input }],
            customClass: [{ type: core.Input }],
            active: [{ type: core.HostBinding, args: ['class.active',] }, { type: core.Input }],
            selectTab: [{ type: core.Output }],
            deselect: [{ type: core.Output }],
            removed: [{ type: core.Output }],
            addClass: [{ type: core.HostBinding, args: ['class.tab-pane',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            ariaLabelledby: [{ type: core.HostBinding, args: ['attr.aria-labelledby',] }]
        };
TabDirective.ɵfac = function TabDirective_Factory(t) { return new (t || TabDirective)(ɵngcc0.ɵɵdirectiveInject(TabsetComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
TabDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TabDirective, selectors: [["tab"], ["", "tab", ""]], hostVars: 7, hostBindings: function TabDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("aria-labelledby", ctx.ariaLabelledby)("id", ctx.id);
        ɵngcc0.ɵɵclassProp("tab-pane", ctx.addClass)("active", ctx.active);
    } }, inputs: { customClass: "customClass", active: "active", removable: "removable", heading: "heading", id: "id", disabled: "disabled" }, outputs: { selectTab: "selectTab", deselect: "deselect", removed: "removed" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabDirective, [{
        type: core.Directive,
        args: [{ selector: 'tab, [tab]' }]
    }], function () { return [{ type: TabsetComponent }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { selectTab: [{
            type: core.Output
        }], deselect: [{
            type: core.Output
        }], removed: [{
            type: core.Output
        }], addClass: [{
            type: core.HostBinding,
            args: ['class.tab-pane']
        }], role: [{
            type: core.HostBinding,
            args: ['attr.role']
        }], customClass: [{
            type: core.Input
        }], active: [{
            type: core.HostBinding,
            args: ['class.active']
        }, {
            type: core.Input
        }], ariaLabelledby: [{
            type: core.HostBinding,
            args: ['attr.aria-labelledby']
        }], removable: [{
            type: core.Input
        }], heading: [{
            type: core.Input
        }], id: [{
            type: core.HostBinding,
            args: ['attr.id']
        }, {
            type: core.Input
        }], disabled: [{
            type: core.Input
        }] }); })();
        return TabDirective;
    }());
    if (false) {
        /**
         * tab header text
         * @type {?}
         */
        TabDirective.prototype.heading;
        /**
         * tab id. The same id with suffix '-link' will be added to the corresponding &lt;li&gt; element
         * @type {?}
         */
        TabDirective.prototype.id;
        /**
         * if true tab can not be activated
         * @type {?}
         */
        TabDirective.prototype.disabled;
        /**
         * if true tab can be removable, additional button will appear
         * @type {?}
         */
        TabDirective.prototype.removable;
        /**
         * fired when tab became active, $event:Tab equals to selected instance of Tab component
         * @type {?}
         */
        TabDirective.prototype.selectTab;
        /**
         * fired when tab became inactive, $event:Tab equals to deselected instance of Tab component
         * @type {?}
         */
        TabDirective.prototype.deselect;
        /**
         * fired before tab will be removed, $event:Tab equals to instance of removed tab
         * @type {?}
         */
        TabDirective.prototype.removed;
        /** @type {?} */
        TabDirective.prototype.addClass;
        /** @type {?} */
        TabDirective.prototype.role;
        /** @type {?} */
        TabDirective.prototype.headingRef;
        /** @type {?} */
        TabDirective.prototype.tabset;
        /**
         * @type {?}
         * @protected
         */
        TabDirective.prototype._active;
        /**
         * @type {?}
         * @protected
         */
        TabDirective.prototype._customClass;
        /** @type {?} */
        TabDirective.prototype.elementRef;
        /** @type {?} */
        TabDirective.prototype.renderer;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Should be used to mark <ng-template> element as a template for tab heading
     */
    var TabHeadingDirective = /** @class */ (function () {
        /* tslint:disable-next-line:no-any */
        function TabHeadingDirective(templateRef, tab) {
            tab.headingRef = templateRef;
        }
        /** @nocollapse */
        TabHeadingDirective.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: TabDirective }
        ]; };
TabHeadingDirective.ɵfac = function TabHeadingDirective_Factory(t) { return new (t || TabHeadingDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(TabDirective)); };
TabHeadingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TabHeadingDirective, selectors: [["", "tabHeading", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabHeadingDirective, [{
        type: core.Directive,
        args: [{ selector: '[tabHeading]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: TabDirective }]; }, null); })();
        return TabHeadingDirective;
    }());
    if (false) {
        /** @type {?} */
        TabHeadingDirective.prototype.templateRef;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TabsModule = /** @class */ (function () {
        function TabsModule() {
        }
        /**
         * @return {?}
         */
        TabsModule.forRoot = /**
         * @return {?}
         */
        function () {
            return {
                ngModule: TabsModule,
                providers: [TabsetConfig]
            };
        };
TabsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TabsModule });
TabsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TabsModule_Factory(t) { return new (t || TabsModule)(); }, imports: [[common.CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TabsModule, { declarations: [NgTranscludeDirective, TabDirective, TabsetComponent, TabHeadingDirective], imports: [ɵngcc1.CommonModule], exports: [TabDirective, TabsetComponent, TabHeadingDirective, NgTranscludeDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TabsModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule],
                declarations: [
                    NgTranscludeDirective,
                    TabDirective,
                    TabsetComponent,
                    TabHeadingDirective
                ],
                exports: [
                    TabDirective,
                    TabsetComponent,
                    TabHeadingDirective,
                    NgTranscludeDirective
                ]
            }]
    }], function () { return []; }, null); })();
        return TabsModule;
    }());

    exports.NgTranscludeDirective = NgTranscludeDirective;
    exports.TabDirective = TabDirective;
    exports.TabHeadingDirective = TabHeadingDirective;
    exports.TabsModule = TabsModule;
    exports.TabsetComponent = TabsetComponent;
    exports.TabsetConfig = TabsetConfig;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ngx-bootstrap-tabs.umd.js.map